module check

imports
  
  libstratego-lib
  include/CSharp
  lib/editor-common.generated
  lib/nbl/-
  lib/types/-
  lib/task/-
  names
  types

rules // Name binding
  
  // constraint-error:
  //   node -> (node, "Unresolved reference.")
  //   where
  //     nabl-is-unresolved
  //     
  // constraint-error:
  //   node{anno*} -> (node, "Duplicate definition.")
  //   where
  //     duplicate*    := <nabl-get-duplicate-definitions> node;
  //     if NablNsFunction() := <Hd; nabl-uri; nabl-uri-namespace> duplicate* then
  //       // For functions, only cause a duplicate definition error if there are multiple functions with the same parameter types.
  //       definition  := <collect-one(?Def(_))> anno*;
  //       paramTypes  := <nabl-get-property(|NablProp_parameter-types()); insert-results> definition;
  //       paramTypes* := <map(nabl-get-property(|NablProp_parameter-types())); insert-results; collect-all(?paramTypes, conc)> duplicate*;
  //       <gt> (<length> paramTypes*, 1)
  //     end
  //     
  // constraint-error:
  //   node -> (node, $[Ambiguous, could be from [<map(nabl-print-uri); separate-by(|", "); concat-strings> ambiguity'*]])
  //   where
  //     ambiguity*  := <nabl-get-ambiguities> node;
  //     ambiguity'* := <filter(where(nabl-uri-namespace; ?NablNsNamespace()))> ambiguity*;
  //     <gt> (<length> ambiguity'*, 1)

rules // Types
  
  type-of(|ctx):
    FunDef(ty, _, _, st*) -> <fail>
    where
      ty'  := <type-of(|ctx)> ty
    ; exp* :=  <collect-all(?Return(<id>))> st*
    ; map(
        task-create-error-on-failure(|
	      ctx
	    , <type-match(|ctx, Coerce())> [<type-of(|ctx)>, ty]
	    , "incompatible with declared return type")     
	    )
    ; if [] := exp* then
        <type-check(|ctx)> (ty, VoidTy(), "Missing return expression")
      end

  type-of(|ctx):
    Assign(lhs, rhs) -> <fail>
    where
      lty := <type-of(|ctx)> lhs
    ; rty := <type-of(|ctx)> rhs
    ; tc  := <type-match(|ctx, Coerce())> [rty, lty]
  
  type-of(|ctx):
    VarDef(lty, _, rhs) -> <fail>
    where
      rty := <type-of(|ctx)> rhs
    ; tc  := <type-match(|ctx, Coerce())> [rty, lty]
  