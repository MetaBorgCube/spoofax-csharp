module old-names
  
  version 0.1
  status under development
  
  author Gabriel Konat, TU Delft
  author Guido Wachsmuth (g.h.wachsmuth@tudelft.nl), TU Delft
  
  test suite tests/simple
  test suite tests/complex
  
imports

	nbl/-
  include/CSharp
  desugar
  types
  
namespaces

  Program
  Namespace
  Using
  
  Class

  Function
  Field
  
  Variable
  
binding rules // Namespaces 

  Namespace(x, _) :
    defines non-unique Namespace x
    scopes Namespace, Class
    
  UsingPart(x) :
    imports Class from Namespace x into subsequent scope
    
  UsingPart(u, x) :
    refers to Namespace x in Namespace y
    where u refers to Namespace y
  
binding rules // Classes

	description --
	
		A class `x`, seriously, scopes its fields and functions.
	
	--
	
	example [[
		class x {
			
		}
	]]
	
  Class(x, _) :
    defines unique Class x of type Type(x)
    scopes Field, Function
  
  description --
	
		In the same way, classes with parents scope their fields and functions.
		Additionally, they import fields and functions from their ancestors.
	
	--
	 
  Class(x, y, _) :
    defines unique Class x of type Type(x)
    scopes Field, Function
    imports Field, imported Field, Function, imported Function from Class y
    
  Interface(x, _) :
    defines unique Class x of type Type(x)
    scopes Function
    
  Interface(x, y, _) :
    defines unique Class x of type Type(x)
    scopes Function
    imports Function, imported Function from Class y
    
  PartialClass(x, _) :
    defines non-unique Class x of type Type(x)
    scopes Field, Function
    
  PartialClass(x, y, _) :
    defines non-unique Class x of type Type(x)
    scopes Field, Function
    imports Field, imported Field, Function, imported Function from Class y
    
  Type(c) :
  	refers to Class c
  	
binding rules // Fields

  
  FieldDef(t, x) :
    defines Field x of type t 
    
  todo Gabriel Konat: --
  
  	Add where clause.
	
	--
	
	discuss --
	
		Documentation features are pretty cool, aren't they?

	--
	
	fixme Gabriel Konat, Guido Wachsmuth: --
	
		Field accesses are never resolved.
	
	--
	
  FieldAccess(exp, f) :
    refers to Field f in Class exp
    //where exp has type Type(e)

binding rules // Functions

  FunDef(t, x, _) :
    defines Function x of type t

  FunDef(t, x, _, _) :
    defines Function x of type t 
    scopes Variable, Field
    
  FunCall(exp, f, args) :
    refers to Function f of type (arg-types, _) in Class e
    where exp has type Type(e)
    where args has type arg-types
    
  FunCall(x, args) : 
    refers to Function x of type (arg-types, _)
    where args has type arg-types
    
  Param(t, x) :
    defines Variable x of type t 
    
binding rules // Variables

  VarDef(t, x, _) :
    defines Variable x of type t in subsequent scope 

  VarDef(t, x) :
    defines Variable x of type t in subsequent scope 

	InferredVarDef(x, e):
		defines Variable x of type t in subsequent scope
		where e has type t
		
  VarRef(x) :
    refers to Variable x otherwise
    refers to Field x
  
binding rules // Control flow

  For(t, x, init, cond, stmt, body) :
    defines Variable x of type t in cond, stmt, body

  ForEach(t, x, e, body) :
    defines Variable x of type t in body

  Block(stmt*) : 
    scopes Variable
    