module types

imports
	
  include/CSharp
  lib/editor-common.generated
  lib/nbl/-
  new-names

signature 

  constructors

	  BoolType   : Type
	  IntType    : Type
	  StringType : Type
	  VoidType   : Type

rules // Type projections
  
  // Literals
  type-of:
    True() -> <type-of> BoolType()
    
  type-of:
    False() -> <type-of> BoolType()
      
  type-of:
    IntLit(_) -> <type-of> IntType()
    
  type-of:
    StrLit(_) -> <type-of> StringType()
  
  type-of:
    BoolType() -> Type("Bool"{<nbl-resolve> Use(URI(Language(<language>), [ID(Class(), "Bool", ())]))})
  
  type-of:
    IntType() -> Type("Int"{<nbl-resolve> Use(URI(Language(<language>), [ID(Class(), "Int", ())]))})
    
  type-of:
    StringType() -> Type("String"{<nbl-resolve> Use(URI(Language(<language>), [ID(Class(), "String", ())]))})
    
  type-of:
    VoidType() -> VoidType()
    
    
  // Modifiers  
  type-of:
    ArrayType(t) -> ArrayType(<type-of> t)
    
    
  // Definitions
  type-of:
    Class(x, _) -> x
    
  type-of:
    Class(x, _, _) -> x
  
  type-of:
    PartialClass(x, _) -> x
    
  type-of:
    PartialClass(x, _, _) -> x
  
  type-of:
    FieldDef(t, _) -> t
  
  type-of:
    FunDef(t, _, _) -> t
  
  type-of:
    FunDef(t, _, _, _) -> t
  
  type-of:
    VarDef(t, _) -> t
    
  type-of:
    VarDef(t, _, _) -> t
    
  type-of:
    Param(t, _) -> t
  
  
  // Expressions
  type-of:
    Return(e) -> <type-of> e
  
  type-of:
    VarRef(f) -> <nbl-resolve; type-of> f
  
  type-of:
    FieldAccess(e, f) -> <nbl-resolve; type-of> f
    
  type-of:
    FunCall(e, m, _) -> <nbl-resolve; type-of> m
    
  type-of:
    FunCall(m, _) -> <nbl-resolve; type-of> m

  type-of:
  	Add(_, _) -> <type-of> IntType()
  	
  type-of:
    Sub(_, _) -> <type-of> IntType()
    
  type-of:
    Mul(_, _) -> <type-of> IntType()
    
  type-of:
    Div(_, _) -> <type-of> IntType()


  // NBL
  type-of:
    Def(uri) -> <nbl-get-property(|Type()); type-of> uri
    
  type-of:
    Type(t@_{anno*}) -> <nbl-resolve; type-of> t
    where
      not(<collect-one(?Def(_))> anno*)
    
  type-of:
    Type(t@_{anno*}) -> <id>
    where
      <collect-one(?Def(_))> anno*
      
rules // Comparison

  is-assignable-to:
    (to-type, from-type) -> to-type
    where
      <eq> (<type-of> from-type, <type-of> to-type)

rules // Utility
	
  print-type = 
    switch id
      case ?VoidType() : !"void"
      case ?IntType() : !"int"
      case ?StringType() : !"string"
      case ?Type("String") : !"string"
      case ?Type("Int") : !"int"
      case ?Type(t) : <strip-annos> t
      case ?[type|[]] : <print-type> type
      case ?[type|types]; not(<?[]> types) : !$[[<print-type> type], [<print-type> types]]
      case is-string : id
      case ?name#(_) : !$[[name]]
      otherwise : id
    end
