module types

imports
	
  include/CSharp
  lib/types/-
  lib/nbl/-
  
	names
  
signature 

  sorts
    
    Ty

  constructors

    Ty : ID -> Ty

	  BoolTy   : Ty
	  IntTy    : Ty
	  StringTy : Ty
	  VoidTy   : Ty

signature constructors

  Coerce   : Relation
  BinCoerce: Relation
  
rules // coercion
  
  
  task-match: (Coerce(), [x, x])                    -> x
  task-match: (Coerce(), [IntTy(), StringTy()]) -> StringTy()
  
  task-match: (BinCoerce(), [t1, t2]) -> <task-match> (Coerce(), [t1, t2])
  task-match: (BinCoerce(), [t1, t2]) -> <task-match> (Coerce(), [t2, t1])
  

rules // literals
  
  // Literals
  type-of(|ctx): True()    -> <type-is(|ctx)> BoolTy()
  type-of(|ctx): False()   -> <type-is(|ctx)> BoolTy()
  type-of(|ctx): IntLit(_) -> <type-is(|ctx)> IntTy()
  type-of(|ctx): StrLit(_) -> <type-is(|ctx)> StringTy()
  
rules // adopted
  
  type-of(|ctx):
    Add(e1, e2) -> <type-match(|ctx, BinCoerce())> [t1, t2]
    where
      t1 := <type-check(|ctx)> (e1, [IntTy(), StringTy()])
    ; t2 := <type-check(|ctx)> (e2, [IntTy(), StringTy()])

  type-of(|ctx):
    _ -> <type-is(|ctx, [t1, t2])> IntTy()
    where
    	?Sub(e1, e2)
    + ?Mul(e1, e2)
    + ?Div(e1, e2)
    where
    	t1 := <type-check(|ctx)> (e1, [IntTy()])
    ; t2 := <type-check(|ctx)> (e2, [IntTy()])

  type-of(|ctx):
    _ -> <type-is(|ctx, [tc])> BoolTy()
    where
      ?Lt(e1, e2)
    + ?Gt(e1, e2)
    + ?Lte(e1, e2)
    + ?Gte(e1, e2)
    where
      t1 := <type-check(|ctx)> (e1, [IntTy(), StringTy()])
    ; t2 := <type-check(|ctx)> (e2, [IntTy(), StringTy()])
    ; tc := <type-match(|ctx, BinCoerce())> [t1, t2]

type-of(|ctx):
    Eq(e1, e2) -> <type-is(|ctx, [tc])> BoolTy()
    where
      t1 := <type-check(|ctx)> (e1, [BoolTy(), IntTy(), StringTy()])
    ; t2 := <type-check(|ctx)> (e2, [BoolTy(), IntTy(), StringTy()])
    ; tc := <type-match(|ctx, BinCoerce())> [t1, t2]

rules // names
	      
  type-of(|ctx): VarRef(v)         -> <type-lookup(|ctx)> v
  type-of(|ctx): FieldAccess(e, f) -> <type-lookup(|ctx)> f
  type-of(|ctx): FunCall(e, m, _)  -> <type-lookup(|ctx)> m
  type-of(|ctx): FunCall(m, _)     -> <type-lookup(|ctx)> m
  type-of(|ctx): This()            -> <type-lookup(|ctx)> 
  type-of(|ctx): Super()           -> <type-lookup(|ctx)> 

  type-of(|ctx) = map(type-of(|ctx)); type-is(|ctx)
  	
// rules // Utility
// 	
//   print-type = 
//     switch id
//       case ?"String" : !"string"
//       case ?"Int" : !"int"
//       case ?VoidTy() : !"void"
//       case ?IntTy() : !"int"
//       case ?StringTy() : !"string"
//       case ?Ty(t) : <print-type> t
//       case ?TyExp(t) : <print-type> t
//       case ?TyPart(t) : <print-type> t
//       case ?TyPart(q, t) : <concat-strings> [<print-type> q, ".", <print-type> t]
//       case ?[type|[]] : <print-type> type
//       case ?[type|types]; not(<?[]> types) : !$[[<print-type> type], [<print-type> types]]
//       case is-string : strip-annos
//       case ?name#(_) : !$[[name]]
//       otherwise : id
//     end
