module types

imports
	
  include/CSharp
  lib/index-library.generated
  lib/analysis-library.generated
  new-names

signature constructors

  BoolType   : Type
  IntType    : Type
  StringType : Type
  VoidType   : Type

rules // Type projections
    
  type-of:
    Return(e) -> <type-of> e  

  type-of:
    True() -> <type-of> BoolType()
    
  type-of:
    False() -> <type-of> BoolType()
      
  type-of:
    IntLit(_) -> <type-of> IntType()
    
  type-of:
    StrLit(_) -> <type-of> StringType()
  
  type-of:
  	BoolType() -> Type("Bool"{[Class(), "Bool"]})
  
  type-of:
    IntType() -> Type("Int"{[Class(), "Int"]})
    
  type-of:
    StringType() -> Type("String"{[Class(), "String"]})
    
  type-of:
    VoidType() -> VoidType()
  
  type-of:
    VarRef(f) -> <type-of> <index-lookup> f
  
  type-of:
    FieldAccess(e, f) -> <type-of> <index-lookup> f
    
  type-of:
    FunCall(e, m, _) -> <type-of> <index-lookup> m
    
  type-of:
    FunCall(m, _) -> <type-of> <index-lookup> m

  // Lazy resolving of types because index-lookup during use analysis on data fails for imports.
  type-of:
    Type(t{[Unresolved(Class())|_]}) -> Type(name{uri})
    where
      Def(uri) := <index-lookup> t;
      name := <strip-annos> t
      
  type-of:
    Type(t{[Class()|_]}) -> <id> 

  type-of:
    Def(uri) -> <type-of> <index-get-data(|Type())> Def(uri)
    
rules // Comparison

  is-assignable-to:
    (to-type, from-type) -> to-type
    where
      <eq> (from-type, to-type)
    
rules // Utility
	
  print-type = 
    switch id
      case ?VoidType() : !"void"
      case ?IntType() : !"int"
      case ?StringType() : !"string"
      case ?Type("String") : !"string"
      case ?Type("Int") : !"int"
      case ?Type(t) : <strip-annos> t
      case ?[type|[]] : <print-type> type
      case ?[type|types]; not(<?[]> types) : !$[[<print-type> type], [<print-type> types]]
      case is-string : id
      case ?name#(_) : !$[[name]]
      otherwise : id
    end
