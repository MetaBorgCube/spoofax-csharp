module type/expressions

imports
  include/CSharp
  type/-
  types/-
  task/-
  
rules // literals
  
  // Literals
  type-of(|ctx): True()    -> <type-is(|ctx)> BoolTy()
  type-of(|ctx): False()   -> <type-is(|ctx)> BoolTy()
  type-of(|ctx): IntLit(_) -> <type-is(|ctx)> IntTy()
  type-of(|ctx): StrLit(_) -> <type-is(|ctx)> StringTy()
  
rules // binary operators
  
  type-of(|ctx):
    Add(e1, e2) -> t
    where
      t1 := <type-of(|ctx); type-match(|ctx, [IntTy(), StringTy()])> e1
    ; t2 := <type-of(|ctx); type-match(|ctx, [IntTy(), StringTy()])> e2
    ; t  := <type-match(|ctx, BinCoerce(), t2)> t1
    ; <task-create-error-on-failure(|ctx, t1, INT_OR_STRING_MSG())> e1
    ; <task-create-error-on-failure(|ctx, t2, INT_OR_STRING_MSG())> e2
  
  type-of(|ctx):
    _ -> <type-is(|ctx, [t1, t2])> IntTy()
    where
      ?Sub(e1, e2)
    + ?Mul(e1, e2)
    + ?Div(e1, e2)
    where
      t1 := <type-of(|ctx); type-match(|ctx, IntTy())> e1
    ; t2 := <type-of(|ctx); type-match(|ctx, IntTy())> e2
    ; <task-create-error-on-failure(|ctx, t1, INT_MSG())> e1
    ; <task-create-error-on-failure(|ctx, t2, INT_MSG())> e2
 
  type-of(|ctx):
    _ -> <type-is(|ctx, [t1, t2])> BoolTy()
    where
      ?Lt(e1, e2)
    + ?Gt(e1, e2)
    + ?Lte(e1, e2)
    + ?Gte(e1, e2)
    where
      t1 := <type-of(|ctx); type-match(|ctx, [IntTy(), StringTy()])> e1
    ; t2 := <type-of(|ctx); type-match(|ctx, [IntTy(), StringTy()])> e2
    ; <task-create-error-on-failure(|ctx, t1, INT_OR_STRING_MSG())> e1
    ; <task-create-error-on-failure(|ctx, t2, INT_OR_STRING_MSG())> e2
    
  type-of(|ctx):
    Eq(e1, e2) -> <type-is(|ctx, [tc])> BoolTy()
    where
      t1 := <type-of(|ctx); type-match(|ctx, [BoolTy(), IntTy(), StringTy()])> e1
    ; t2 := <type-of(|ctx); type-match(|ctx, [BoolTy(), IntTy(), StringTy()])> e2
    ; tc := <type-match(|ctx, BinCoerce(), t2)> t1
    ; <task-create-error-on-failure(|ctx, t1, COMPARE_MSG())> e1
    ; <task-create-error-on-failure(|ctx, t2, COMPARE_MSG())> e2
    ; <task-create-error-on-failure(|ctx, tc, EQ_MSG())> e2

rules
  
  
rules // references
        
  type-of(|ctx): VarRef(v)         -> <type-lookup(|ctx)> v
  type-of(|ctx): FieldAccess(e, f) -> <type-lookup(|ctx)> f
  type-of(|ctx): FunCall(e, m, _)  -> <type-lookup(|ctx)> m
  type-of(|ctx): FunCall(m, _)     -> <type-lookup(|ctx)> m
  type-of(|ctx): This()            -> <type-lookup(|ctx)> 
  type-of(|ctx): Super()           -> <type-lookup(|ctx)> 

  type-of(|ctx) = map(type-of(|ctx)); type-is(|ctx)
  