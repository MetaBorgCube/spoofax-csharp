module types/check

imports
  
  libstratego-lib
  include/CSharp
  lib/nabl/-
  lib/types/-
  lib/task/-
  types/-

rules // Name binding
  
  // constraint-error:
  //   node -> (node, "Unresolved reference.")
  //   where
  //     nabl-is-unresolved
  //     
  // constraint-error:
  //   node{anno*} -> (node, "Duplicate definition.")
  //   where
  //     duplicate*    := <nabl-get-duplicate-definitions> node;
  //     if NablNsFunction() := <Hd; nabl-uri; nabl-uri-namespace> duplicate* then
  //       // For functions, only cause a duplicate definition error if there are multiple functions with the same parameter types.
  //       definition  := <collect-one(?Def(_))> anno*;
  //       paramTypes  := <nabl-get-property(|NablProp_parameter-types()); insert-results> definition;
  //       paramTypes* := <map(nabl-get-property(|NablProp_parameter-types())); insert-results; collect-all(?paramTypes, conc)> duplicate*;
  //       <gt> (<length> paramTypes*, 1)
  //     end
  //     
  // constraint-error:
  //   node -> (node, $[Ambiguous, could be from [<map(nabl-print-uri); separate-by(|", "); concat-strings> ambiguity'*]])
  //   where
  //     ambiguity*  := <nabl-get-ambiguities> node;
  //     ambiguity'* := <filter(where(nabl-uri-namespace; ?NablNsNamespace()))> ambiguity*;
  //     <gt> (<length> ambiguity'*, 1)

rules // Types
  
  nabl-constraint(|ctx) =
    ?FunDef(ty, _, _, st*)
  ; exp* := <collect-all(where(return-error(|ctx, ty)))> st*
  ; if [] := exp* then
      tc := <type-match(|ctx, VoidType())> ty
    ; <task-create-error-on-failure(|ctx, tc, "Missing return expression")> ty
    end
  
  return-error(|ctx, rty) =
    ?Return(exp)
  ; ty := <type-of(|ctx)> exp
  ; tc := <type-match(|ctx, Coerce(), rty)> ty
  ; <task-create-error-on-failure(|ctx, tc, "incompatible with declared return type")> exp    
    
  nabl-constraint(|ctx) =
  ( ?Assign(lhs, rhs)
  ; lty := <type-of(|ctx)> lhs
  + ?VarDef(lty, lhs, rhs)
  + ?For(lty, lhs, rhs, exp, _, _)
  ; ety := <type-of(|ctx)> exp
  ; bc := <type-match(|ctx, BoolTy())> ety
  ; <task-create-error-on-failure(|ctx, bc, BOOL_MSG())> exp
 )
  ; rty := <type-of(|ctx)> rhs
  ; tc  := <type-match(|ctx, Coerce(), rty)> lty
  ; <task-create-error-on-failure(|ctx, tc, "type mismatch")> lhs
 
  nabl-constraint(|ctx) =
  ( ?If(exp, _)
  + ?IfElse(exp, _, _)
  )
  ; tc := <type-of(|ctx); type-match(|ctx, BoolTy())> exp
  ; <task-create-error-on-failure(|ctx, tc, BOOL_MSG())> exp
 