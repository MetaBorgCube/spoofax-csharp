module new-names

imports 
	
	include/CSharp
	lib/task/core
	lib/nbl/-
	types
	old-names
	
signature 

  constructors // Namespaces
	
	// 	Program   : Namespace
	// 	Namespace : Namespace
	// 	Class     : Namespace
	//   Field     : Namespace 
	//   Function  : Namespace
	// 	Variable  : Namespace
	
	constructors // Properties
	  
	// Type           : Property
	// ParameterTypes : Property
	
rules // Type property
	
  calc-property: 
  	(Type(), x) -> <type-of> x
	
rules // Namespaces
  
  // Namespace(x, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?Namespace(x, _);
  //   Namespace(nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Namespace(), NonUnique(), Current(), [Namespace(), Class()]), 
  //   id)
	
	
	// Using(x)
  nabl-import-site(|lang, partition, elem*, uri*, states) =
    ?Using(x);
    Using(nabl-import(|lang, partition, elem*, uri*, [
      Import(lang, NablNsClass())
    ]))

	// UsingPart(x)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?UsingPart(x);
  //   UsingPart(nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Namespace(), [], Current(), All())]
  //   ))	
    

	// UsingPart(u, x)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?UsingPart(u, x);
  //   where (target-uri* := <nabl-collect-all-use; map(nabl-uri)> u);
  //   UsingPart(id, nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Namespace(), [], target-uri*, One())]
  //   ))
	
rules // Classes
	
	// Class(x, _)
	// nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
	// 	?Class(x, _);
	// 	Class(nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
	// 	  Class(), Unique(), Current(), [Field(), Function()]), 
	//   id)

	// nabl-prop-site(|elem*, states) =
	// 	?Class(x, _);
	// 	Class(nabl-props(|elem*, [
	// 		Prop(Type(), Type(x))
	// 	]), id)
		
  nabl-implicit-def-site(|lang, partition, unique*, elem*, uri*, states) =
    ?Class(x, _);
    Class(nabl-implicit-def(|lang, partition, unique*, elem*, uri*, [
      IDefCandidate(NablNsField(), "this", Unique(), [Prop(Type(), Type(x))])
    ]), id)
    
		
	// Class(x, y, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?Class(x, y, _);
  //   Class(nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Class(), Unique(), Current(), [Field(), Function()]), 
  //   id, id)
  
  // nabl-prop-site(|elem*, states) =
  //   ?Class(x, y, _);
  //   Class(nabl-props(|elem*, [
  //   	Prop(Type(), Type(x))
  // 	]), id, id)
    
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?Class(x, y, _);
  //   Class(id, nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Class(), [], Current(), All())]), 
  //   id)
    
  nabl-import-site(|lang, partition, elem*, uri*, states) =
    ?Class(x, y, _);
    Class(id, nabl-import(|lang, partition, elem*, uri*, [
    	Import(lang, NablNsField()), 
      Import(lang, Imported(NablNsField())), 
      Import(lang, NablNsFunction()), 
      Import(lang, Imported(NablNsFunction()))
    ]), id)
    
  nabl-implicit-def-site(|lang, partition, unique*, elem*, uri*, states) =
    ?Class(x, y, _);
    Class(nabl-implicit-def(|lang, partition, unique*, elem*, uri*, [
      IDefCandidate(NablNsField(), "this", Unique(), [Prop(Type(), Type(x))])
    ]), nabl-implicit-def(|lang, partition, unique*, elem*, uri*, [
      IDefCandidate(NablNsField(), "super", Unique(), [Prop(Type(), Type(y))])
    ]), id)

  
  // PartialClass(x, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?PartialClass(x, _);
  //   PartialClass(nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*,
  //     Class(), NonUnique(), Current(), [Field(), Function()]),
  //   id)
  
  // nabl-prop-site(|elem*, states) =
  //   ?PartialClass(x, _);
  //   PartialClass(nabl-props(|elem*, [
  //   	Prop(Type(), Type(x))
  // 	]), id)
    
  nabl-implicit-def-site(|lang, partition, unique*, elem*, uri*, states) =
    ?PartialClass(x, _);
    Class(nabl-implicit-def(|lang, partition, unique*, elem*, uri*, [
      IDefCandidate(NablNsField(), "this", Unique(), [Prop(Type(), Type(x))])
    ]), id)
    
    
  // PartialClass(x, y, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?PartialClass(x, y, _);
  //   PartialClass(nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Class(), NonUnique(), Current(), [Field(), Function()]), 
  //   id, id)
  
  // nabl-prop-site(|elem*, states) =
  //   ?PartialClass(x, y, _);
  //   PartialClass(nabl-props(|elem*, [
  //   	Prop(Type(), Type(x))]), 
  // 	id, id)
    	
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?PartialClass(x, y, _);
  //   PartialClass(id, nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Class(), [], Current(), All())]), 
  //   id)
  
  nabl-import-site(|lang, partition, elem*, uri*, states) =
    ?PartialClass(x, y, _);
    PartialClass(id, nabl-import(|lang, partition, elem*, uri*, [
      Import(lang, NablNsField()), 
      Import(lang, Imported(NablNsField())), 
      Import(lang, NablNsFunction()), 
      Import(lang, Imported(NablNsFunction()))
    ]), id)
    
  nabl-implicit-def-site(|lang, partition, unique*, elem*, uri*, states) =
    ?PartialClass(x, y, _);
    Class(nabl-implicit-def(|lang, partition, unique*, elem*, uri*, [
      IDefCandidate(NablNsField(), "this", Unique(), [Prop(Type(), Type(x))])
    ]), nabl-implicit-def(|lang, partition, unique*, elem*, uri*, [
      IDefCandidate(NablNsField(), "super", Unique(), [Prop(Type(), Type(y))])
    ]), id)


  // TypePart(x)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?TypePart(x);
  //   TypePart(nabl-use(|lang, partition, elem*, uri*, [
  //     UseCandidate(NablNsNamespace(), [], Current(), All())
  //   , UseCandidate(NablNsClass(), [], Current(), All())
  //   ])) 
    

  // TypePart(q, x)
  nabl-use-site(|lang, partition, elem*, uri*, states) =
    ?TypePart(q, x);
    where (target-uri* := <nabl-collect-all-use; map(nabl-uri)> q);
    TypePart(id, nabl-use(|lang, partition, elem*, uri*, [
      UseCandidate(NablNsNamespace(), [], target-uri*, One())
    , UseCandidate(NablNsClass(), [], target-uri*, One())
    ]))
		
		
  // This()
  nabl-use-site(|lang, partition, elem*, uri*, states) =
    ?This();
    //where (result1 := <new-task(|task*)> Resolve([<lookup-uri(|lang, NablNsField())> uri*], NablNsField(), "this", [], All()));
    where (result1 := <nabl-use-candidate(|lang, partition, elem*, uri*, "this")> UseCandidate(NablNsField(), [], Current(), All()));
    where (result2 := <new-task(|partition)> PropCalc(Type(), result1));
    where (result3 := <new-task(|partition)> Match("nabl-use-site_match_This_0", [], result2));
    nabl-use(|lang, partition, elem*, uri*,
     [UseCandidate(NablNsClass(), result3, [], Current(), One())]
    )

	// A resolve task returns a list of URI's (result1), so when the type is calculated (result2) a list of types is
	// returned as well. So the first type in the list is taken.      
  nabl-match: ("nabl-use-site_match_This_0", types, []) -> <fetch-elem(?Type(<id>))> types
  
  // Super()
  nabl-use-site(|lang, partition, elem*, uri*, states) =
    ?Super();
    //where (result1 := <new-task(|task*)> Resolve([<lookup-uri(|lang, NablNsField())> uri*], NablNsField(), "super", [], All()));
    where (result1 := <nabl-use-candidate(|lang, partition, elem*, uri*, "super")> UseCandidate(NablNsField(), [], Current(), All()));
    where (result2 := <new-task(|partition)> PropCalc(Type(), result1));
    where (result3 := <new-task(|partition)> Match("nabl-use-site_match_This_0", [], result2));
    nabl-use(|lang, partition, elem*, uri*,
      [UseCandidate(NablNsClass(), result3, [], Current(), One())]
    )
	
rules // Fields
	
	// FieldDef(t, x)
	// nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
 //  	?FieldDef(t, x);
	// 	FieldDef(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
	// 	  Field(), Unique(), Current(), []
	//   ))
		
  // nabl-prop-site(|elem*, states) =
  //   ?FieldDef(t, x);
  //   FieldDef(id, nabl-props(|elem*, [
  //     Prop(Type(), t)
  //   ]))

    
  // FieldAccess(e, f)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?FieldAccess(e, f);
  //   where (result1 := <new-task(|task*)> PropCalc(Type(), e));
  //   where (result2 := <new-task(|task*)> Match("nabl-use-site_match_FieldAccess_2", [], result1));
  //   FieldAccess(id, nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Field(), [], [result2], One())]
  //   ))
    
  // nabl-match: ("nabl-use-site_match_FieldAccess_2", Type(t), []) -> t
      
rules // Functions
  
  // FunDef(t, x, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?FunDef(t, x, _);
  //   FunDef(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Function(), Unique(), Current(), []), 
  //   id)
    
  // nabl-prop-site(|elem*, states) =
  //   ?FunDef(t, x, p);
  //   where (result := <new-task(|task*)> PropCalc(Type(), p));
  //   FunDef(id, nabl-props(|elem*, [
  //   	Prop(Type(), t)
  //   , Prop(ParameterTypes(), result)
  // 	]), id)
    
  
  // FunDef(t, x, _, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?FunDef(t, x, _, _);
  //   FunDef(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Function(), Unique(), Current(), [Variable()]), 
  //   id, id)
    
  // nabl-prop-site(|elem*, states) =
  //   ?FunDef(t, x, p, _);
  //   where (result := <new-task(|task*)> PropCalc(Type(), p));
  //   FunDef(id, nabl-props(|elem*, [
  //   	Prop(Type(), t)
  //   , Prop(ParameterTypes(), result)
  // 	]), id, id)
    
  
  // FunCall(e, f, a)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?FunCall(e, x, a);
  //   where (result1 := <new-task(|task*)> PropCalc(Type(), e));
  //   where (result2 := <new-task(|task*)> Match("nabl-use-site_match_FunCall_3", [], result1));
  //   where (result3 := <new-task(|task*)> PropCalc(Type(), a));
  //   FunCall(id, nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Function(), [Prop(ParameterTypes(), result3)], [result2], One())]), 
  //   id)
  //   
  // nabl-match: ("nabl-use-site_match_FunCall_3", Type(t), []) -> t
  
  // FunCall(x, a)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?FunCall(x, a);
  //   where (result := <new-task(|task*)> PropCalc(Type(), a));
  //   FunCall(nabl-use(|lang, partition, elem*, uri*,
  //     [UseCandidate(Function(), [Prop(ParameterTypes(), result)], Current(), All())]), 
  //   id)

  
  // Param(t, x)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?Param(t, x);
  //   Param(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*,
  //     Variable(), Unique(), Current(), []
  //   ))
    
  // nabl-prop-site(|elem*, states) =
  //   ?Param(t, x);
  //   Param(id, nabl-props(|elem*, [
  //   	Prop(Type(), t)
  // 	]))
  
rules // Variable
  
  // VarDef(t, x, _)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?VarDef(t, x, _);
  //   VarDef(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Variable(), Unique(), [Subsequent()], []), 
  //   id)
    
  // nabl-prop-site(|elem*, states) =
  //   ?VarDef(t, x, _);
  //   VarDef(id, nabl-props(|elem*, [
  //   	Prop(Type(), t)
  // 	]), id)
    
  
  // VarDef(t, x)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?VarDef(t, x);
  //   VarDef(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Variable(), Unique(), [Subsequent()], []
  //   ))
    
  // nabl-prop-site(|elem*, states) =
  //   ?VarDef(t, x);
  //   VarDef(id, nabl-props(|elem*, [
  //   	Prop(Type(), t)
  // 	]))
    
    
  // InferredVarDef(x, e)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =
  //   ?InferredVarDef(x, e);
  //   InferredVarDef(nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Variable(), Unique(), [Subsequent()], []
  //   ), id)
    
  // nabl-prop-site(|elem*, states) =
  //   ?InferredVarDef(x, e);
  //   where (result := <new-task(|task*)> PropCalc(Type(), e));
  //   InferredVarDef(nabl-props(|elem*, [
  //     Prop(Type(), result)
  //   ]), id)
    
  // VarRef(x)
  // nabl-use-site(|lang, partition, elem*, uri*, states) =
  //   ?VarRef(x);
  //   VarRef(nabl-use(|lang, partition, elem*, uri*, [
  //   	UseCandidate(NablNsVariable(), [], Current(), All()), 
  //   	UseCandidate(NablNsField(), [], Current(), All())
  // 	]))

rules // Control flow
  
  // For(t, x, init, cond, stmt, body) 
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =    
  //   ?For(t, x, init, cond, stmt, body);
  //   where(scope := <nabl-construct-def-scope(|lang, partition, unique*)> Variable());
  //   For(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Variable(), Unique(), [scope], []), id, nabl-def-scope(|scope), 
  //     nabl-def-scope(|scope), nabl-def-scope(|scope)
  //   )
    
  // nabl-prop-site(cpaths, spaths|elem*, states) =   
  //   ?For(t, x, init, cond, stmt, body);
  //   For(id, nabl-props(|elem*, [
  //   	Prop(Type(), t)
  // 	]), id, id, id, id)
  
  
  // ForEach(t, x, e, body)
  // nabl-def-site(cpaths, spaths|lang, partition, unique*, elem*, uri*, states) =    
  //   ?ForEach(t, x, e, body);
  //   where(scope := <nabl-construct-def-scope(|lang, partition, unique*)> Variable());
  //   ForEach(id, nabl-def(cpaths, spaths|lang, partition, unique*, elem*, uri*, 
  //     Variable(), Unique(), [scope], []), id, nabl-def-scope(|scope)
  //   )
    
  // nabl-prop-site(cpaths, spaths|elem*, states) =   
  //   ?ForEach(t, x, e, body);
  //   ForEach(id, nabl-props(|elem*, [
  //     Prop(Type(), t)
  //   ]), id, id)
  
  
  // Block(stmt*)
  // nabl-anonymous-scope-site(cpaths|lang, partition, unique*, uri*, states) =   
  //   ?Block(stmt*);
  //   nabl-anonymous-scope(cpaths|lang, partition, unique*, uri*, [
  //     Variable()
  //   ])

rules // Name projections
  
  nabl-name:
    UsingPart(q, x) -> x

  nabl-name-apply(s):
    UsingPart(q, x) -> UsingPart(q, <s> x)
    
  nabl-name:
    UsingPart(x) -> x
    
  nabl-name-apply(s):
    UsingPart(x) -> UsingPart(<s> x)
    
  nabl-name:
    TypePart(q, x) -> x

  nabl-name-apply(s):
    TypePart(q, x) -> TypePart(q, <s> x)
    
  nabl-name:
    TypePart(x) -> x
    
  nabl-name-apply(s):
    TypePart(x) -> TypePart(<s> x)
    
rules // Scoping projections

//   nabl-scopes = ?(Program(), Namespace())
//   nabl-scopes = ?(Program(), Class())
//   
//   nabl-scopes = ?(Namespace(), Namespace())
//   nabl-scopes = ?(Namespace(), Class())
//   
//   nabl-scopes = ?(Class(), Field())
//   nabl-scopes = ?(Class(), Function())
// 
//   nabl-scopes = ?(Function(), Variable())
  
